package MyFirstPackage;

import java.util.ArrayList;
import java.io.BufferedWriter;
import java.io.File;  // Import the File class
import java.io.IOException;  // Import the IOException class to handle errors
import java.io.FileWriter;   // Import the FileWriter class
import java.io.FileInputStream;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Iterator;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;

import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.hssf.usermodel.HSSFDateUtil;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook; 


public class ExcelReader  
{  	
	public static void output(String[][][] out) {
		String max = out.get(cellNum-2);
		String min = out.get(cellNum-1);
		String base = out.get(cellNum-3);
		System.out.print("Max:" + max);
		System.out.print(" Min:" + min);
		System.out.print(" Base:" + base);
		try {
			FileWriter myWriter = new FileWriter("output.txt", true);

			System.out.print("first item when write to out: " + out.get(0)+"\n");
			
			//Style 1: 
			myWriter.write("Ng√†y " +  + ", ");
			
			
		    myWriter.close();
		    System.out.println("Successfully wrote to the file.");
		}
		catch (IOException e){
			System.out.println("An error occurred.");
		    e.printStackTrace();
			
		}
		
	}
	
	public static void outputRestart() {
		try {
			FileWriter myWriter = new FileWriter("output.txt");
			myWriter.write("\n");
		    
		    myWriter.close();
		    System.out.println("Successfully clear output");
		}
		catch (IOException e){
			System.out.println("An error occurred in output clearing.");
		    e.printStackTrace();
			
		}
	}
	
	public static void checkOutputFile() {
	try {
		File myObj = new File("output.txt");
		if (myObj.createNewFile()) {
			System.out.println("File created: " + myObj.getName());
	    } else {
	        System.out.println("File already exists.");
	    }
	 } catch (IOException e) {
	      System.out.println("An error occurred.");
	      e.printStackTrace();
	 }
		
	}
	static XSSFRow row;
	public static void main(String args[])throws Exception { 
		outputRestart();
		ArrayList<String> Column = new ArrayList<String>();
		String[][][] dayData = new String[3][21][10];
		
		
		checkOutputFile();
		
	  File file = new File("D:\\Java Workspace\\3-STOCK-INDEX.xlsx");
	  FileInputStream fIP = new FileInputStream(file);
      int i = 0;
      int j = 0;
      int k = 0;
      
	  XSSFWorkbook workbook = new XSSFWorkbook(fIP);
      XSSFSheet spreadsheetVN_INDEX = workbook.getSheetAt(0);
      Iterator < Row >  rowIterator0 = spreadsheetVN_INDEX.iterator();

      while (rowIterator0.hasNext()) { 	  
         row = (XSSFRow) rowIterator0.next();
         Iterator < Cell >  cellIterator = row.cellIterator();
         
         while ( cellIterator.hasNext()) {

            Cell cell = cellIterator.next();
            switch (cell.getCellType()) {
               case Cell.CELL_TYPE_NUMERIC:
            	  if (HSSFDateUtil.isCellDateFormatted(cell)) {
            		  DateFormat df = new SimpleDateFormat("dd/MM/yyyy");
            		  dayData[i][j][k] = df.format(cell.getDateCellValue()); 		  
            	  } 
            	  break;
               
               case Cell.CELL_TYPE_STRING:
            	   dayData[i][j][k] = cell.getStringCellValue();
            	   break;
            }
            k++;
         }
         k = 0;
         System.out.println();
         j++;
      }
      j = 0;
      i++;
      
      XSSFSheet spreadsheetUPCOM_INDEX = workbook.getSheetAt(1);
      Iterator < Row >  rowIterator1 = spreadsheetUPCOM_INDEX.iterator();

      
      while (rowIterator1.hasNext()) { 	  
         row = (XSSFRow) rowIterator1.next();
         Iterator < Cell >  cellIterator = row.cellIterator();
         
         while ( cellIterator.hasNext()) {
            Cell cell = cellIterator.next();
            switch (cell.getCellType()) {
               case Cell.CELL_TYPE_NUMERIC:
            	  if (HSSFDateUtil.isCellDateFormatted(cell)) {
            		  DateFormat df = new SimpleDateFormat("dd/MM/yyyy");
            		  dayData[i][j][k] = df.format(cell.getDateCellValue()); 		  
            	  } 
            	  break;
               
               case Cell.CELL_TYPE_STRING:
            	   System.out.print(cell.getStringCellValue() + " \t\t ");
            	   dayData[i][j][k] = cell.getStringCellValue();
            	   break;
            }
            k++;
         }
         k = 0;
         System.out.println();
         j++;
      }
      j = 0;
      i++;
      
      XSSFSheet spreadsheetHNX_INDEX = workbook.getSheetAt(2);
      Iterator < Row >  rowIterator2 = spreadsheetHNX_INDEX.iterator();

      
      while (rowIterator2.hasNext()) { 	  
         row = (XSSFRow) rowIterator2.next();
         Iterator < Cell >  cellIterator = row.cellIterator();
         
         while ( cellIterator.hasNext()) {
            Cell cell = cellIterator.next();
            switch (cell.getCellType()) {
               case Cell.CELL_TYPE_NUMERIC:
            	  if (HSSFDateUtil.isCellDateFormatted(cell)) {
            		  DateFormat df = new SimpleDateFormat("dd/MM/yyyy");
            		  System.out.print("bruh");
            		  dayData[i][j][k] = df.format(cell.getDateCellValue()); 		  
            	  } 
            	  break;
               
               case Cell.CELL_TYPE_STRING:
            	   System.out.print(cell.getStringCellValue() + " \t\t ");
            	   dayData[i][j][k] = cell.getStringCellValue();
            	   break;
               case Cell.CELL_TYPE_BLANK:
            	   break;
            }
            k++;
         }
         k = 0;
         System.out.println();
         j++;
      }
      j = 0;
      i++;
      
      for (int j1 = 0; j1<21; j1++) {
    	  for (int k1 = 0; k1<10; k1++) {
    		  System.out.print(" "+dayData[1][j1][k1]+" ");  	  
    	  }
    	  System.out.println();
      }
      fIP.close();
	}  
}  